package invoice

import (
	"context"
	"fmt"
	"log"
	"strings"
	"time"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgxpool"
)

// Repository defines persistence operations for invoices.
type Repository interface {
	Create(ctx context.Context, inv *Invoice) error
	Update(ctx context.Context, inv *Invoice) error
	Delete(ctx context.Context, id uuid.UUID) error
	GetByID(ctx context.Context, id uuid.UUID) (*Invoice, error)
	GetByExternalID(ctx context.Context, id uuid.UUID) (*Invoice, error)
	List(ctx context.Context, filter ListInvoicesFilter) ([]*Invoice, error)
}

type repositoryImpl struct {
	db *pgxpool.Pool
}

func NewRepository(db *pgxpool.Pool) Repository {
	return &repositoryImpl{db: db}
}

func (r *repositoryImpl) Create(ctx context.Context, inv *Invoice) error {
	log.Printf("Repository: Creating invoice for member ID: %s, invoice number: %s", inv.MemberID, inv.InvoiceNumber)

	// total_amount is generated by the database (amount + tax_amount)
	query := `
		INSERT INTO invoices (
			id, invoice_number, member_id, branch_id, subscription_id, amount, tax_amount, status, due_date, paid_at, notes, external_id
		) VALUES (
			COALESCE($1, uuid_generate_v4()), $2, $3, $4, $5, $6, $7, COALESCE($8::invoice_status_enum, 'pending'::invoice_status_enum), $9, $10, $11, $12
		)
		RETURNING id, total_amount, created_at, updated_at
	`
	var id uuid.UUID
	var totalAmount float64
	err := r.db.QueryRow(ctx, query,
		nullUUID(inv.ID),
		inv.InvoiceNumber,
		inv.MemberID,
		inv.BranchID,
		inv.SubscriptionID,
		inv.Amount,
		inv.TaxAmount,
		inv.Status,
		inv.DueDate,
		inv.PaidAt,
		inv.Notes,
		inv.ExternalID,
	).Scan(&id, &totalAmount, &inv.CreatedAt, &inv.UpdatedAt)

	if err != nil {
		log.Printf("Repository: Failed to create invoice for member ID %s: %v", inv.MemberID, err)
		return err
	}

	inv.ID = id
	inv.TotalAmount = totalAmount
	log.Printf("Repository: Invoice created successfully with ID: %s for member ID: %s", inv.ID, inv.MemberID)
	return nil
}

func (r *repositoryImpl) Update(ctx context.Context, inv *Invoice) error {
	query := `
		UPDATE invoices
		SET branch_id = $1,
			subscription_id = $2,
			amount = $3,
			tax_amount = $4,
			status = $5,
			due_date = $6,
			paid_at = $7,
			notes = $8,
			external_id = $9,
			updated_at = NOW()
		WHERE id = $10
		RETURNING id, member_id, subscription_id, total_amount, updated_at
	`
	return r.db.QueryRow(ctx, query,
		inv.BranchID,
		inv.SubscriptionID,
		inv.Amount,
		inv.TaxAmount,
		inv.Status,
		inv.DueDate,
		inv.PaidAt,
		inv.Notes,
		inv.ExternalID,
		inv.ID,
	).Scan(&inv.ID, &inv.MemberID, &inv.SubscriptionID, &inv.TotalAmount, &inv.UpdatedAt)
}

func (r *repositoryImpl) Delete(ctx context.Context, id uuid.UUID) error {
	// Hard delete because invoices table does not define deleted_at in the migration snippet.
	_, err := r.db.Exec(ctx, `DELETE FROM invoices WHERE id = $1`, id)
	return err
}

func (r *repositoryImpl) GetByID(ctx context.Context, id uuid.UUID) (*Invoice, error) {
	query := `
		SELECT id, invoice_number, member_id, branch_id, subscription_id,
			   amount, tax_amount, total_amount, status, due_date, paid_at, notes, external_id,
			   created_at, updated_at
		FROM invoices
		WHERE id = $1
	`
	var inv Invoice
	if err := r.db.QueryRow(ctx, query, id).Scan(
		&inv.ID,
		&inv.InvoiceNumber,
		&inv.MemberID,
		&inv.BranchID,
		&inv.SubscriptionID,
		&inv.Amount,
		&inv.TaxAmount,
		&inv.TotalAmount,
		&inv.Status,
		&inv.DueDate,
		&inv.PaidAt,
		&inv.Notes,
		&inv.ExternalID,
		&inv.CreatedAt,
		&inv.UpdatedAt,
	); err != nil {
		return nil, err
	}
	return &inv, nil
}

func (r *repositoryImpl) GetByExternalID(ctx context.Context, id uuid.UUID) (*Invoice, error) {
	query := `
		SELECT id, invoice_number, member_id, branch_id, subscription_id,
			   amount, tax_amount, total_amount, status, due_date, paid_at, notes, external_id,
			   created_at, updated_at
		FROM invoices
		WHERE external_id = $1
	`
	var inv Invoice
	if err := r.db.QueryRow(ctx, query, id).Scan(
		&inv.ID,
		&inv.InvoiceNumber,
		&inv.MemberID,
		&inv.BranchID,
		&inv.SubscriptionID,
		&inv.Amount,
		&inv.TaxAmount,
		&inv.TotalAmount,
		&inv.Status,
		&inv.DueDate,
		&inv.PaidAt,
		&inv.Notes,
		&inv.ExternalID,
		&inv.CreatedAt,
		&inv.UpdatedAt,
	); err != nil {
		return nil, err
	}
	return &inv, nil
}

func (r *repositoryImpl) List(ctx context.Context, filter ListInvoicesFilter) ([]*Invoice, error) {
	// Base query. We will optionally join branches to filter by organization.
	var sb strings.Builder
	sb.WriteString(`
		SELECT i.id, i.invoice_number, i.member_id, i.branch_id, i.subscription_id,
			   i.amount, i.tax_amount, i.total_amount, i.status, i.due_date, i.paid_at, i.notes, i.external_id,
			   i.created_at, i.updated_at
		FROM invoices i
	`)

	args := make([]any, 0, 8)
	conds := make([]string, 0, 8)
	argIdx := 1
	joinedBranches := false

	// Organization filter via branches join
	if filter.OrganizationID != nil {
		sb.WriteString(` JOIN branches b ON b.id = i.branch_id `)
		joinedBranches = true
		conds = append(conds, fmt.Sprintf("b.organization_id = $%d", argIdx))
		args = append(args, *filter.OrganizationID)
		argIdx++
	}

	// Branch filter
	if filter.BranchID != nil {
		conds = append(conds, fmt.Sprintf("i.branch_id = $%d", argIdx))
		args = append(args, *filter.BranchID)
		argIdx++
	}

	// Member filter
	if filter.MemberID != nil {
		conds = append(conds, fmt.Sprintf("i.member_id = $%d", argIdx))
		args = append(args, *filter.MemberID)
		argIdx++
	}

	// Subscription filter
	if filter.SubscriptionID != nil {
		conds = append(conds, fmt.Sprintf("i.subscription_id = $%d", argIdx))
		args = append(args, *filter.SubscriptionID)
		argIdx++
	}

	// Status filter
	if filter.Status != nil && *filter.Status != "" {
		conds = append(conds, fmt.Sprintf("i.status = $%d", argIdx))
		args = append(args, *filter.Status)
		argIdx++
	}

	// Date filtering
	dateField := strings.ToLower(strings.TrimSpace(filter.DateField))
	switch dateField {
	case "due_date":
		// Filter on due_date
		if filter.StartDate != nil {
			conds = append(conds, fmt.Sprintf("i.due_date >= $%d", argIdx))
			args = append(args, *filter.StartDate)
			argIdx++
		}
		if filter.EndDate != nil {
			conds = append(conds, fmt.Sprintf("i.due_date <= $%d", argIdx))
			args = append(args, *filter.EndDate)
			argIdx++
		}
	default:
		// Default to created_at
		if filter.StartDate != nil {
			conds = append(conds, fmt.Sprintf("i.created_at >= $%d", argIdx))
			args = append(args, *filter.StartDate)
			argIdx++
		}
		if filter.EndDate != nil {
			conds = append(conds, fmt.Sprintf("i.created_at <= $%d", argIdx))
			args = append(args, *filter.EndDate)
			argIdx++
		}
	}

	// WHERE clause
	if len(conds) > 0 {
		sb.WriteString(" WHERE ")
		sb.WriteString(strings.Join(conds, " AND "))
	}

	// Order and pagination
	page := filter.Page
	limit := filter.Limit
	if page < 1 {
		page = 1
	}
	if limit < 1 {
		limit = 10
	}
	offset := (page - 1) * limit

	sb.WriteString(" ORDER BY i.created_at DESC ")
	sb.WriteString(fmt.Sprintf(" LIMIT $%d OFFSET $%d", argIdx, argIdx+1))
	args = append(args, limit, offset)

	// Execute query
	rows, err := r.db.Query(ctx, sb.String(), args...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	invoices := make([]*Invoice, 0, limit)
	for rows.Next() {
		var inv Invoice
		if err := rows.Scan(
			&inv.ID,
			&inv.InvoiceNumber,
			&inv.MemberID,
			&inv.BranchID,
			&inv.SubscriptionID,
			&inv.Amount,
			&inv.TaxAmount,
			&inv.TotalAmount,
			&inv.Status,
			&inv.DueDate,
			&inv.PaidAt,
			&inv.Notes,
			&inv.ExternalID,
			&inv.CreatedAt,
			&inv.UpdatedAt,
		); err != nil {
			return nil, err
		}
		invoices = append(invoices, &inv)
	}

	_ = joinedBranches // reserved for future logic if needed
	return invoices, nil
}

// Helpers

// nullUUID converts zero UUID to nil for COALESCE in insert.
func nullUUID(id uuid.UUID) *uuid.UUID {
	if id == uuid.Nil {
		return nil
	}
	return &id
}

func nullString(s string) *string {
	if strings.TrimSpace(s) == "" {
		return nil
	}
	return &s
}

// Utility for date normalization if needed downstream.
func normalizeDateRange(start, end *time.Time) (s, e *time.Time) {
	if start != nil && end != nil && end.Before(*start) {
		// Swap to ensure start <= end
		return end, start
	}
	return start, end
}
